diff --git a/lisp/term/ns-win.el b/lisp/term/ns-win.el
index 46639f2422b..75e0c251af5 100644
--- a/lisp/term/ns-win.el
+++ b/lisp/term/ns-win.el
@@ -588,6 +588,88 @@ string dropped into the current buffer."
   (interactive)
   (ns-show-character-palette))

+(declare-function ns--share-items "nsfns.m" (items))
+
+(defun ns-share (&optional items)
+  "Share ITEMS (list of files or string) via macOS service.
+
+When ITEMS are missing, derive as follows.
+
+From `dired', ITEMS are based on either of these being active:
+
+  - Marked files (list).
+  - Files in region (list).
+  - File at point (list).
+
+Anywhere else, these being active:
+
+  - Region (string).
+  - Current buffer file (list)."
+  (interactive)
+  (unless items
+    (setq items (ns--shareable-items)))
+  (unless items
+    (user-error "Nothing to share"))
+  (ns--share-items items))
+
+(defun ns--shareable-items ()
+  "Figure out what user wants to share based on context.
+
+From `dired', shared items are based on either of these being active:
+
+  - Marked files
+  - Files in region.
+  - File at point.
+
+Anywhere else, these being active:
+
+  - Region (sent as text).
+  - Current buffer file (if one is available)."
+  (cond ((derived-mode-p 'dired-mode)
+         (or
+          (ns--dired-filenames-in-region)
+          (dired-get-marked-files)))
+        ((use-region-p)
+         (list (buffer-substring-no-properties
+                (region-beginning)
+                (region-end))))
+        ((buffer-file-name)
+         (list (buffer-file-name)))))
+
+(defun ns--dired-filenames-in-region ()
+  "If `dired' buffer, return region files.  nil otherwise."
+  (when (and (equal major-mode 'dired-mode)
+             (use-region-p))
+    (let ((start (region-beginning))
+          (end (region-end))
+          (marked-files (let ((files (dired-get-marked-files)))
+                          (cond ((null (cdr files))
+                                 nil)
+                                ((and (= (length files) 2)
+                                      (eq (car files) t))
+                                 t)
+                                (t
+                                 (not (seq-empty-p files))))))
+          (filenames))
+      (when marked-files
+        (user-error "Mark dired files or select region.  Not both."))
+      (save-excursion
+        (save-restriction
+          (goto-char start)
+          (while (< (point) end)
+            ;; Skip non-file lines.
+            (while (and (< (point) end) (dired-between-files))
+              (forward-line 1))
+            (when (and (dired-get-filename nil t)
+                       ;; Ensure filename is fully selected.
+                       (< (save-excursion
+                            (forward-line 0)
+                            (dired-move-to-filename))
+                          end))
+              (setq filenames (append filenames (list (dired-get-filename nil t)))))
+            (forward-line 1))))
+      filenames)))
+
 (defun ns-next-frame ()
   "Switch to next visible frame."
   (interactive)
diff --git a/src/nsfns.m b/src/nsfns.m
index 9f52777879c..ca45bc1f415 100644
--- a/src/nsfns.m
+++ b/src/nsfns.m
@@ -3764,6 +3764,79 @@ The position is returned as a cons cell (X . Y) of the
   return Qnil;
 }

+static NSPoint
+ns_get_point_relative_coordinates (NSView* view)
+{
+  Lisp_Object coordinate = Fnth (make_fixnum (2), Fposn_at_point (Fpoint (), Qnil));
+
+  int x = ^{
+    Lisp_Object value = Fcar (coordinate);
+    if (NILP (value))
+      {
+        signal_error ("No x coordinate found", coordinate);
+      }
+    return XFIXNUM (value);
+  }();
+
+  int y = ^{
+    Lisp_Object value = Fcdr (coordinate);
+    if (NILP (value))
+    {
+      signal_error ("No y coordinate found", coordinate);
+    }
+    return XFIXNUM (value);
+  }();
+
+  return [view convertPoint:NSMakePoint (x, y) toView:nil];
+}
+
+DEFUN ("ns-send-items",
+       Fns_send_items,
+       Sns_send_items, 1, 1, 0,
+       doc: /* Send a list of items to macOS apps or services. */)
+       (Lisp_Object items)
+{
+  CHECK_LIST (items);
+
+  NSMutableArray *sent = [NSMutableArray array];
+  for (Lisp_Object tail = items; CONSP (tail); tail = XCDR (tail))
+  {
+    Lisp_Object elt = XCAR (tail);
+    if (!(STRINGP (elt)))
+    {
+      signal_error ("Element not a string", elt);
+    }
+    BOOL isDir;
+    if ([[NSFileManager defaultManager] fileExistsAtPath:@(SSDATA(elt)) isDirectory:&isDir]) {
+      [sent addObject:[NSURL fileURLWithPath:@(SSDATA(elt))]];
+      continue;
+    }
+    [sent addObject:@(SSDATA(elt))];
+  }
+
+  struct frame *frame = SELECTED_FRAME ();
+  struct window *window = XWINDOW (selected_window);
+
+  int text_area_x, text_area_y, text_area_width, text_area_height;
+  window_box (window, TEXT_AREA, &text_area_x, &text_area_y,
+              &text_area_width, &text_area_height);
+
+  int x = text_area_x + window->phys_cursor.x;
+  int y = text_area_y + window->phys_cursor.y;
+
+  /* Position menu below character at point */
+  NSPoint viewPoint = NSMakePoint(x + FRAME_COLUMN_WIDTH (frame) / 2,
+				  y + FRAME_LINE_HEIGHT (frame) + 10);
+
+  EmacsView *view = FRAME_NS_VIEW (frame);
+  NSSharingServicePicker *picker = [[NSSharingServicePicker alloc] initWithItems:sent];
+  [picker showRelativeToRect:NSMakeRect(viewPoint.x - 1, viewPoint.y - 1, 2, 2)
+		      ofView:view
+	       preferredEdge:NSRectEdgeMaxY];
+
+  return Qnil;
+}
+
 /* ==========================================================================

     Class implementations
@@ -3996,6 +4069,7 @@ - (Lisp_Object)lispString
   defsubr (&Sns_set_mouse_absolute_pixel_position);
   defsubr (&Sns_mouse_absolute_pixel_position);
   defsubr (&Sns_show_character_palette);
+  defsubr (&Sns_send_items);
   defsubr (&Sx_display_mm_width);
   defsubr (&Sx_display_mm_height);
   defsubr (&Sx_display_screens);
